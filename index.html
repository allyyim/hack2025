<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ADO PRism - Real-Time Knowledge Signals</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .container {
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            text-align: center;
            max-width: 900px;
            width: 90%;
        }

        h2 {
            color: #333;
            font-size: 28px;
            margin: 0 0 20px 0;
            font-weight: 600;
            line-height: 1.4;
        }

        p {
            color: #666;
            font-size: 16px;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 14px 40px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: 600;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #999;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            margin-top: 20px;
            font-size: 14px;
            color: #666;
            min-height: 20px;
        }

        .status.loading {
            color: #667eea;
            font-weight: 600;
        }

        .status.success {
            color: #28a745;
            font-weight: 600;
        }

        .status.error {
            color: #dc3545;
            font-weight: 600;
        }

        #commentsContainer {
            display: none;
            margin-top: 30px;
            text-align: left;
            max-height: 600px;
            overflow-y: auto;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: #fafafa;
            font-size: 14px;
            line-height: 1.6;
        }

        #commentsContainer.visible {
            display: block;
        }

        #commentsContent {
            white-space: pre-wrap;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(102, 126, 234, 0.3);
            border-radius: 50%;
            border-top-color: #667eea;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .progress-3 {
            width: 100%;
            height: 20px;
            border-radius: 20px;
            background:
                repeating-linear-gradient(135deg, #6babbf 0 10px, #bf6b81 0 20px) 0/0% no-repeat,
                repeating-linear-gradient(135deg, #ddd 0 10px, #eee 0 20px) 0/100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            transition: background-size 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- PRism Logo -->
        <svg width="80" height="80" viewBox="0 0 100 100" style="margin-bottom:20px;">
            <!-- Prism shape -->
            <defs>
                <linearGradient id="prismGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color:#667eea;stop-opacity:1" />
                    <stop offset="50%" style="stop-color:#764ba2;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#f093fb;stop-opacity:1" />
                </linearGradient>
                <linearGradient id="lightBeam" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color:#ffffff;stop-opacity:0.8" />
                    <stop offset="100%" style="stop-color:#667eea;stop-opacity:0.3" />
                </linearGradient>
            </defs>
            
            <!-- Incoming light beam -->
            <line x1="5" y1="50" x2="30" y2="50" stroke="url(#lightBeam)" stroke-width="8" opacity="0.6"/>
            
            <!-- Prism triangle -->
            <polygon points="35,30 35,70 65,50" fill="url(#prismGradient)" stroke="#5a67d8" stroke-width="2" opacity="0.9"/>
            
            <!-- Spectrum rays coming out -->
            <line x1="65" y1="50" x2="95" y2="35" stroke="#f093fb" stroke-width="3" opacity="0.8"/>
            <line x1="65" y1="50" x2="95" y2="45" stroke="#764ba2" stroke-width="3" opacity="0.8"/>
            <line x1="65" y1="50" x2="95" y2="55" stroke="#667eea" stroke-width="3" opacity="0.8"/>
            <line x1="65" y1="50" x2="95" y2="65" stroke="#4c51bf" stroke-width="3" opacity="0.8"/>
            
            <!-- Small dots representing data points -->
            <circle cx="88" cy="35" r="2" fill="#f093fb"/>
            <circle cx="90" cy="45" r="2" fill="#764ba2"/>
            <circle cx="90" cy="55" r="2" fill="#667eea"/>
            <circle cx="88" cy="65" r="2" fill="#4c51bf"/>
        </svg>
        
        <h2>ADO PRism</h2>
        <p class="tagline" style="font-size:18px;font-weight:500;color:#667eea;margin-bottom:10px;">Transforming PR discussions into consumable knowledge signals</p>
        <p>Transforms PR comments into structured knowledge signals using Azure OpenAI. Extracts terms, troubleshooting steps, and best practices as consumable signals - so teams can discover insights without rebuilding extraction pipelines.</p>
        <div style="display:flex;gap:12px;justify-content:center;">
            <button id="subscribeBtn" onclick="openComments()">Discover What's Important</button>
        </div>
        <div id="status" class="status"></div>
        <div id="commentsContainer">
            <h3 style="margin-top:0;color:#333;">Important Comments</h3>
            <div id="commentsContent"></div>
        </div>
    </div>

    <script>
        async function fetchComments() {
            const button = document.getElementById('fetchBtn');
            const status = document.getElementById('status');
            
            button.disabled = true;
            status.textContent = 'Fetching comments...';
            status.className = 'status loading';

            try {
                const response = await fetch('/api/fetch-comments', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    status.textContent = '✓ Comments fetched successfully! Check important_comments.md';
                    status.className = 'status success';
                } else {
                    const error = await response.text();
                    status.textContent = `✗ Error: ${error}`;
                    status.className = 'status error';
                }
            } catch (error) {
                status.textContent = `✗ Connection error: ${error.message}`;
                status.className = 'status error';
            } finally {
                button.disabled = false;
            }
        }

        async function openComments() {
            const button = document.getElementById('subscribeBtn');
            const status = document.getElementById('status');
            const container = document.getElementById('commentsContainer');
            const content = document.getElementById('commentsContent');
            
            button.disabled = true;
            status.innerHTML = `
                <div id="progressContainer" style="display:flex;flex-direction:column;gap:10px;width:100%;">
                    <span class="loading-spinner"></span>
                    <div style="font-weight:500;">Analyzing up to 20 PRs from the last 30 days...</div>
                    <div class="progress-3" id="progressBar">0/20</div>
                    <div id="progressText" style="font-size:14px;color:#666;font-weight:500;">Preparing to analyze PRs...</div>
                </div>
            `;
            status.className = 'status loading';
            console.log('Progress bar initialized');

            // Immediately reset progress to 0 on the client side
            let clientProgress = { total: 20, processed: 0, found: 0, currentPR: 0 };

            console.log('[FRONTEND] Starting progress polling NOW');
            
            // Poll for progress updates
            const progressInterval = setInterval(async () => {
                try {
                    // Aggressive cache busting with multiple techniques
                    const timestamp = Date.now();
                    const random = Math.random();
                    const progressResp = await fetch(`/api/progress?t=${timestamp}&r=${random}`, {
                        cache: 'no-store',
                        headers: {
                            'Cache-Control': 'no-cache, no-store, must-revalidate',
                            'Pragma': 'no-cache',
                            'Expires': '0'
                        }
                    });
                    if (progressResp.ok) {
                        const progress = await progressResp.json();
                        console.log('[FRONTEND POLL] Received from server:', progress);
                        // Always update with server progress (trust the backend)
                        clientProgress = progress;
                        console.log('[FRONTEND UPDATE] Updated clientProgress to:', clientProgress);
                        const progressBar = document.getElementById('progressBar');
                        const progressText = document.getElementById('progressText');
                        
                        // If elements don't exist anymore, stop polling
                        if (!progressBar || !progressText) {
                            console.log('[FRONTEND] Progress elements removed, stopping polling');
                            clearInterval(progressInterval);
                            return;
                        }
                        
                        if (clientProgress.total === -1) {
                            // Fetching PRs phase
                            progressBar.style.width = '100%';
                            progressBar.textContent = '...';
                            progressText.textContent = 'Fetching PRs from Azure DevOps...';
                            console.log('[FRONTEND RENDER] Fetching phase active');
                        } else if (clientProgress.total > 0) {
                            // Analyzing phase
                            const percentage = Math.round((clientProgress.processed / clientProgress.total) * 100);
                            // Set background-size for both gradients (colored stripe, gray stripe)
                            progressBar.style.backgroundSize = `${percentage}%, 100%`;
                            progressBar.textContent = `${clientProgress.processed}/${clientProgress.total}`;
                            console.log(`[FRONTEND RENDER] Updated progressBar: ${clientProgress.processed}/${clientProgress.total} (${percentage}%) - backgroundSize: ${percentage}%`);
                            
                            // Update text immediately even if no PRs processed yet
                            if (clientProgress.processed === 0) {
                                progressText.textContent = `Starting analysis of ${clientProgress.total} PRs...`;
                            } else if (clientProgress.currentPR > 0) {
                                progressText.textContent = `Parsed ${clientProgress.processed} out of ${clientProgress.total} PRs • ${clientProgress.found} with important comments • Currently: PR #${clientProgress.currentPR}`;
                            } else {
                                progressText.textContent = `Parsed ${clientProgress.processed} out of ${clientProgress.total} PRs • ${clientProgress.found} with important comments`;
                            }
                        } else {
                            console.log('[FRONTEND RENDER] Waiting for progress data...', clientProgress);
                        }
                    } else {
                        console.warn('Progress endpoint returned:', progressResp.status);
                    }
                } catch (e) {
                    console.error('Progress polling error:', e);
                }
            }, 300);

            try {
                // Use relative URL so it works both locally and on Azure
                // Add timestamp to force fresh analysis
                console.log('[FRONTEND] Calling /important-comments endpoint NOW');
                const response = await fetch(`/important-comments?force=true&t=${Date.now()}`);
                
                // Clear interval and keep progress bar visible
                clearInterval(progressInterval);
                
                // Update progress bar to show completion
                const progressBar = document.getElementById('progressBar');
                const progressText = document.getElementById('progressText');
                const spinner = document.querySelector('.loading-spinner');
                if (progressBar && progressText) {
                    progressBar.style.backgroundSize = '100%, 100%';
                    progressBar.textContent = `${clientProgress.processed}/${clientProgress.total}`;
                    progressText.textContent = '✓ Analysis complete! View important comments below.';
                    progressText.style.color = '#28a745';
                    progressText.style.fontWeight = 'bold';
                }
                if (spinner) {
                    spinner.style.display = 'none';
                }

                if (response.ok) {
                    const html = await response.text();
                    // Parse the HTML response and extract body content
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    const bodyContent = doc.querySelector('body');
                    
                    if (bodyContent) {
                        // Insert the HTML content directly (it includes <details> tags)
                        content.innerHTML = bodyContent.innerHTML;
                        container.classList.add('visible');
                        // Keep status in success state with progress bar visible
                        status.className = 'status success';
                    } else {
                        content.innerHTML = html;
                        container.classList.add('visible');
                        status.className = 'status success';
                    }
                } else {
                    status.textContent = `✗ Error loading comments: ${response.status}`;
                    status.className = 'status error';
                }
            } catch (error) {
                status.textContent = `✗ Connection error: ${error.message}`;
                status.className = 'status error';
            } finally {
                button.disabled = false;
            }
        }
    </script>
</body>
</html>
